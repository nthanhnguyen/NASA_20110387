class Parser {
  constructor(fun) {
    this.fun = fun;
  }
  parse(input, index = 0) {
    return this.fun(input, index);
  }
  map(fun) {
    return new Parser((input, index) => {
      const r = this.fun(input, index);
      if (!r.ok)
        return r;
      return Ok(r.index, fun(r.value));
    });
  }
  filter(fun, expected) {
    return new Parser((input, index) => {
      const r = this.fun(input, index);
      if (!r.ok || fun(r.value))
        return r;
      return Error(r.index, expected);
    });
  }
  optional(default_) {
    return new Parser((input, index) => {
      const r = this.fun(input, index);
      if (r.ok || r.index > index)
        return r;
      return Ok(index, default_);
    });
  }
  bind(b) {
    return new Parser((input, index) => {
      const r = this.fun(input, index);
      if (!r.ok)
        return r;
      return b(r.value).fun(input, r.index);
    });
  }
  then(b) {
    return new Parser((input, index) => {
      const r = this.fun(input, index);
      if (!r.ok)
        return r;
      const rb = b.fun(input, r.index);
      if (!rb.ok)
        return rb;
      return Ok(rb.index, [r.value, rb.value]);
    });
  }
  thenSkip(b) {
    return new Parser((input, index) => {
      const r = this.fun(input, index);
      if (!r.ok)
        return r;
      const rb = b.fun(input, r.index);
      if (!rb.ok)
        return rb;
      return Ok(rb.index, r.value);
    });
  }
  skipThen(b) {
    return new Parser((input, index) => {
      const r = this.fun(input, index);
      if (!r.ok)
        return r;
      return b.fun(input, r.index);
    });
  }
  between(before, after) {
    return new Parser((input, index) => {
      const rb = before.fun(input, index);
      if (!rb.ok)
        return rb;
      const r = this.fun(input, rb.index);
      if (!r.ok)
        return r;
      const ra = after.fun(input, r.index);
      if (!ra.ok)
        return ra;
      return Ok(ra.index, r.value);
    });
  }
  or(b) {
    return new Parser((input, index) => {
      const r = this.fun(input, index);
      if (r.ok || r.index > index)
        return r;
      const rb = b.fun(input, index);
      if (rb.ok || rb.index > index)
        return rb;
      return Error(index, [r.expected, rb.expected]);
    });
  }
  repeat() {
    return new Parser((input, index) => {
      const value = [];
      for (; ; ) {
        const r = this.fun(input, index);
        if (!r.ok)
          return r.index === index ? Ok(index, value) : r;
        value.push(r.value);
        index = r.index;
      }
    });
  }
  join(b) {
    return new Parser((input, index) => {
      const value = [];
      const r = this.fun(input, index);
      if (!r.ok)
        return r.index === index ? Ok(index, value) : r;
      value.push(r.value);
      index = r.index;
      for (; ; ) {
        const rb = b.fun(input, index);
        if (!rb.ok)
          return rb.index === index ? Ok(index, value) : rb;
        index = rb.index;
        const r2 = this.fun(input, index);
        if (!r2.ok)
          return r2;
        value.push(r2.value);
        index = r2.index;
      }
    });
  }
  chainLeft(op) {
    return this.then(op.then(this).repeat()).map(([head, tail]) => tail.reduce((acc, [op2, right]) => op2(acc, right), head));
  }
  chainRight(op) {
    return this.then(op.then(this).repeat()).map(([head, tail]) => [head].concat(tail.map((t) => t[1])).reduceRight((acc, left, i) => tail[i][0](left, acc)));
  }
  pipe(fun) {
    return fun(this);
  }
}
const p = (a) => typeof a === "function" ? new Parser(a) : typeof a === "string" || Array.isArray(a) ? string(a) : a instanceof RegExp ? regex(a) : a;
const string = (arg) => {
  if (Array.isArray(arg)) {
    const expected2 = arg.map((a) => JSON.stringify(a));
    const re = arg.slice().sort((a, b) => b.length - a.length).map(escapeRegex).join("|");
    return regex(re, { expected: expected2 });
  }
  const expected = JSON.stringify(arg);
  return new Parser((input, index) => {
    if (input.slice(index).startsWith(arg))
      return Ok(index + arg.length, arg);
    return Error(index, expected);
  });
};
const _regex = (arg, expected_) => {
  const [source, flags] = typeof arg === "string" ? [arg, ""] : [arg.source, arg.flags.replace(/y|g/g, "")];
  const expected = expected_ || `/${source}/${flags}`;
  const regex2 = new RegExp(source, flags + "y");
  return [regex2, expected];
};
const regex = (arg, { expected: expected_ } = {}) => {
  const [regex2, expected] = _regex(arg, expected_);
  return new Parser((input, index) => {
    var _a;
    regex2.lastIndex = index;
    const match = (_a = regex2.exec(input)) == null ? void 0 : _a[0];
    if (match !== void 0)
      return Ok(regex2.lastIndex, match);
    return Error(index, expected);
  });
};
const regex_ = (arg, { expected: expected_ } = {}) => {
  const [regex2, expected] = _regex(arg, expected_);
  return new Parser((input, index) => {
    regex2.lastIndex = index;
    if (regex2.test(input))
      return Ok(regex2.lastIndex, void 0);
    return Error(index, expected);
  });
};
const end = () => new Parser((input, index) => index >= input.length ? Ok(index, void 0) : Error(index, "end of input"));
const lazy = (p2) => new Parser((input, index) => p2().fun(input, index));
const or = (ps, { expected } = {}) => {
  if (expected) {
    return new Parser((input, index) => {
      for (const p2 of ps) {
        const r = p2.fun(input, index);
        if (r.ok || r.index > index)
          return r;
      }
      return Error(index, expected);
    });
  }
  return new Parser((input, index) => {
    const expected2 = [];
    for (const p2 of ps) {
      const r = p2.fun(input, index);
      if (r.ok || r.index > index)
        return r;
      expected2.push(r.expected);
    }
    return Error(index, expected2);
  });
};
const succeed = (value) => new Parser((_, index) => Ok(index, value));
const fail = (expected) => new Parser((_, index) => Error(index, expected));
const Ok = (index, value) => ({
  ok: true,
  index,
  value
});
const Error = (index, expected) => ({
  ok: false,
  index,
  expected
});
const escapeRegex = (string2) => string2.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
export { Error, Ok, Parser, p as default, end, fail, lazy, or, p, regex, regex_, string, succeed };
