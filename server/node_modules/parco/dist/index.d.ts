export declare type Result<Output> = Ok<Output> | Error;
export declare type Ok<Output> = {
    ok: true;
    index: number;
    value: Output;
};
export declare type Error = {
    ok: false;
    index: number;
    expected: Expected;
};
export declare type Expected = string | Expected[];
export declare class Parser<Output, Input = string> {
    readonly fun: (input: Input, index: number) => Result<Output>;
    constructor(fun: (input: Input, index: number) => Result<Output>);
    parse(input: Input, index?: number): Result<Output>;
    map<B>(fun: (a: Output) => B): Parser<B, Input>;
    filter(fun: (a: Output) => boolean, expected: Expected): Parser<Output, Input>;
    optional<B>(default_: B): Parser<Output | B, Input>;
    bind<B>(b: (a: Output) => Parser<B, Input>): Parser<B, Input>;
    then<B>(b: Parser<B, Input>): Parser<[Output, B], Input>;
    thenSkip<B>(b: Parser<B, Input>): Parser<Output, Input>;
    skipThen<B>(b: Parser<B, Input>): Parser<B, Input>;
    between<Before, After>(before: Parser<Before, Input>, after: Parser<After, Input>): Parser<Output, Input>;
    or<B>(b: Parser<B, Input>): Parser<Output | B, Input>;
    repeat(): Parser<Output[], Input>;
    join<B>(b: Parser<B, Input>): Parser<Output[], Input>;
    chainLeft(op: Parser<(left: Output, right: Output) => Output, Input>): Parser<Output, Input>;
    chainRight(op: Parser<(left: Output, right: Output) => Output, Input>): Parser<Output, Input>;
    pipe<B>(fun: (_: this) => B): B;
}
export declare type P = {
    <Output, Input = string>(a: (input: Input, index: number) => Result<Output>): Parser<Output, Input>;
    <Output extends string>(a: Output | Output[]): Parser<Output, string>;
    (a: RegExp): Parser<string, string>;
    <Output, Input = string>(a: Parser<Output, Input>): Parser<Output, Input>;
};
export declare const p: P;
export declare const string: <Output extends string>(arg: Output | Output[]) => Parser<Output, string>;
export declare const regex: (arg: RegExp | string, { expected: expected_ }?: {
    expected?: Expected;
}) => Parser<string>;
export declare const regex_: (arg: RegExp | string, { expected: expected_ }?: {
    expected?: Expected;
}) => Parser<void>;
export declare const end: () => Parser<void, string>;
export declare const lazy: <Output, Input>(p: () => Parser<Output, Input>) => Parser<Output, Input>;
export declare const or: <Output, Input = string>(ps: Parser<Output, Input>[], { expected }?: {
    expected?: Expected | undefined;
}) => Parser<Output, Input>;
export declare const succeed: <Output, Input>(value: Output) => Parser<Output, Input>;
export declare const fail: <Output, Input>(expected: Expected) => Parser<Output, Input>;
export declare const Ok: <Output>(index: number, value: Output) => Ok<Output>;
export declare const Error: (index: number, expected: Expected) => Error;
export default p;
